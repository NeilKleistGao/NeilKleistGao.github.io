<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ Class Getting Started(part1)</title>
      <link href="2020/10/03/cpp-class/"/>
      <url>2020/10/03/cpp-class/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一篇受朋友之邀而创作的文章，为了方便阅读，本文使用中文编写。</p><p>本文所使用C++版本为：C++ 17，请注意版本之间的差异带来的影响。</p><p>在正式的项目中，我们一般会将非<code>inline</code>函数的声明和实现分开，本文为了节约空间不采取这种方式。</p><a id="more"></a><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>C++的类（包括很多其他的面向对象语言的类）都使用以下三个关键字来对类内的函数和变量进行访问控制：</p><pre><code class="c++">class Student &#123;public: // 公有，外部和内部均可访问    Student();private: // 私有，仅内部和友元可以访问    int _age;protected: // 保护，仅内部，子类和友元可以访问    bool _is_day_reading;&#125;</code></pre><p>访问控制可以减少用户所能看到（以及所能操作）的函数和变量，这样的设计可以避免用户进行错误的操作，并能减少用户所需要了解的细节。如果一个电灯开关需要用户自己焊接电线，用户很有可能会焊错，这对用户来说是极其不友好的——用户不需要知道这么多实现细节，他只需要知道按下开关，灯泡可以亮起来，这就足够了。</p><p>基于以上的事实，所有用户没必要知道的细节均不应该被标识为<code>public</code>；所有的成员变量也不应该被标识为<code>public</code>，而是应该定义对应的getter/setter函数进行管理。</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="普通构造函数"><a href="#普通构造函数" class="headerlink" title="普通构造函数"></a>普通构造函数</h2><p>编译器会为你生成默认的构造函数和析构函数，除非你可以保证编译器的处理是正确的，否则不要在这一步偷懒：</p><pre><code class="c++">Student(int age) : _age(age) &#123;&#125;</code></pre><p>注意请不要写为：</p><pre><code class="c++">Student(int age) &#123;    _age = age;&#125;</code></pre><p>尤其是当你的成员变量为<code>const</code>的时候，这样的写法将会报错。</p><p>这个构造函数还存在一个问题：</p><pre><code class="c++">Student a = 12;</code></pre><p>这句话是合法的！这意味着在代码中会有很多我们意想不到的隐式转换，这样的转换或者自动类型推断很有可能和我们的预期不符。为了防止这种情况出现，我们需要：</p><pre><code class="c++">explicit Student(int age) : _age(age) &#123;&#125;</code></pre><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>一类特殊的构造函数叫做拷贝构造函数，他通常是为了执行这样的操作而准备的：</p><pre><code class="c++">Student a(12), b(a);</code></pre><p>此时的b就是a的一份拷贝。</p><p>拷贝构造函数一般这样定义：</p><pre><code class="c++">Student(const Student&amp; s) &#123;&#125;</code></pre><p>拷贝构造函数的参数为一个相同类型的常引用。根据标准文件，非常引用也是可以的（但不推荐）：</p><pre><code class="c++">Student(Student&amp; s) &#123;&#125;</code></pre><p>拷贝构造函数也是编译器默认会为你生成的，但如果成员变量中涉及到指针等需要深拷贝的内容，还是需要自己动手丰衣足食。如果你不希望编译器为你生成这样的拷贝构造函数，并且你不希望拷贝行为的产生，你可以这样关闭它：</p><pre><code class="c++">Student(Student&amp; s) = delete;</code></pre><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="普通函数重载"><a href="#普通函数重载" class="headerlink" title="普通函数重载"></a>普通函数重载</h2><p>拥有不同参数类型的函数可以进行重载：</p><pre><code class="c++">void greet() &#123;    std::cout &lt;&lt; &quot;hello&quot; &lt;&lt; std::endl;&#125;void greet(const std::string&amp; name) &#123;    std::cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; std::endl;&#125;</code></pre><p>在调用的时候，编译器会根据不同的参数类型，选择合适的函数：</p><pre><code class="c++">Student s(12);s.greet();s.greet(&quot;world&quot;);</code></pre><p>注意：如果两个函数仅仅只是返回值类型不同，或者修饰符不同，是不能进行重载的。</p><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>除了普通的函数，我们还可以对操作符进行重载：</p><pre><code class="c++">int operator+ (const int&amp; a) &#123;    this-&gt;_age += a;    return this-&gt;_age;&#125;</code></pre><p>大部分的操作符都是可以重载的（从加减乘除到下标逻辑等等），仅以下的几个操作符无法重载：<code>.</code>，<code>?:</code>，<code>::</code>，<code>sizeof</code>，<code>*</code>（引用指向类成员的指针）。尽管如此，除非操作明确（比如两个复数相乘，这个操作是明确的），不要随意重载操作符。部分操作符会造成预料外的问题（如重载<code>&amp;&amp;</code>会造成逻辑判断的阻断无效），有些重载并不能给予明确的意义（向量重载<code>*</code>乘法，究竟是点乘还是叉乘呢？）会误导用户。</p>]]></content>
      
      
      <categories>
          
          <category> Entrusted Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to Count the Number of Words in Python</title>
      <link href="2020/10/03/python-word-count/"/>
      <url>2020/10/03/python-word-count/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一篇受朋友之邀而创作的文章，为了方便阅读，本文使用中文编写。</p><p>本文所使用的解释器版本为：Python 3.8，无需其他依赖库，请注意版本之间的差异带来的影响。</p><a id="more"></a><h1 id="单词计数"><a href="#单词计数" class="headerlink" title="单词计数"></a>单词计数</h1><h2 id="使用字典进行计数"><a href="#使用字典进行计数" class="headerlink" title="使用字典进行计数"></a>使用字典进行计数</h2><p>首先我们需要把一句话划分为数个单词组成的数组：</p><pre><code class="python">article = &quot;I thought what I&#39;d do was I&#39;d pretend I was one of those deaf-mutes.&quot;words = article.split(&#39; &#39;)print(words)</code></pre><p>你的输出应该是类似这样的：</p><pre><code>[&#39;I&#39;, &#39;thought&#39;, &#39;what&#39;, &quot;I&#39;d&quot;, &#39;do&#39;, &#39;was&#39;, &quot;I&#39;d&quot;, &#39;pretend&#39;, &#39;I&#39;, &#39;was&#39;, &#39;one&#39;, &#39;of&#39;, &#39;those&#39;, &#39;deaf-mutes.&#39;]</code></pre><p>然而这并不够完美：<code>deaf-mutes</code>和<code>deaf-mutes.</code>（多了一个英文句号）会被认为是两个单词。我们需要使用正则表达式进行更完美的分割：</p><pre><code class="python">import rearticle = &quot;I thought what I&#39;d do was I&#39;d pretend I was one of those deaf-mutes.&quot;words = re.split(r&quot;[ .;]&quot;, article)print(words)</code></pre><p>虽然这样会导致多出一个空的字符串，但处理空串这比让我们区分<code>deaf-mutes</code>和<code>deaf-mutes.</code>要容易多了。</p><p>接下来建立一个字典，并对单词数量进行统计：</p><pre><code class="python">numbers = &#123;&#125;for word in words:    if word == &quot;&quot;:        continue    if word in numbers:        numbers[word] += 1    else:        numbers[word] = 1print(numbers)</code></pre><p>我们首先建立一个空的字典，并遍历我们刚刚生成的单词列表。如果当前的单词为空，那么忽略它直接处理下一个；否则我们查看该单词在字典中是否已经出现过——如果出现过我们将数字加1,否则这是一个新的单词，将其添加到字典中。</p><p>最后的输出应该类似于这样：</p><pre><code>&#123;&#39;I&#39;: 2, &#39;thought&#39;: 1, &#39;what&#39;: 1, &quot;I&#39;d&quot;: 2, &#39;do&#39;: 1, &#39;was&#39;: 2, &#39;pretend&#39;: 1, &#39;one&#39;: 1, &#39;of&#39;: 1, &#39;those&#39;: 1, &#39;deaf-mutes&#39;: 1&#125;</code></pre><h2 id="按照词频进行排序"><a href="#按照词频进行排序" class="headerlink" title="按照词频进行排序"></a>按照词频进行排序</h2><p>我们可能需要知道出现频率最高的几个单词，这要求我们按照出现频率进行排序。为了实现排序，我们需要将字典转为列表：</p><pre><code class="python">pairs = list(numbers.items())print(pairs)</code></pre><p>我们可以得到：</p><pre><code>[(&#39;I&#39;, 2), (&#39;thought&#39;, 1), (&#39;what&#39;, 1), (&quot;I&#39;d&quot;, 2), (&#39;do&#39;, 1), (&#39;was&#39;, 2), (&#39;pretend&#39;, 1), (&#39;one&#39;, 1), (&#39;of&#39;, 1), (&#39;those&#39;, 1), (&#39;deaf-mutes&#39;, 1)]</code></pre><p>这样的结果：一个包含二元元组的列表。我们只需要按照元组的第二维（实际上是第一维，下标通常都是从0开始的）进行排序即可：</p><pre><code class="python">pairs = sorted(pairs, key=lambda x: x[1], reverse=True)print(pairs)</code></pre><p>这里我们使用了一个<code>lambda</code>表达式来指定排序所使用的键，你也可以使用一个普通的函数来完成。</p><p>输出结果应该类似于这样：</p><pre><code>[(&#39;I&#39;, 2), (&quot;I&#39;d&quot;, 2), (&#39;was&#39;, 2), (&#39;thought&#39;, 1), (&#39;what&#39;, 1), (&#39;do&#39;, 1), (&#39;pretend&#39;, 1), (&#39;one&#39;, 1), (&#39;of&#39;, 1), (&#39;those&#39;, 1), (&#39;deaf-mutes&#39;, 1)]</code></pre><p>接下来我们就可以得到出现次数前k的单词是什么了：</p><pre><code class="python">k = 3for i in range(k):    print(pairs[i][0])</code></pre>]]></content>
      
      
      <categories>
          
          <category> Entrusted Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
